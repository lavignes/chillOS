pkg Ascii;

use UInt;

pub fn compare(lhs: [U8], rhs: [U8]): Int {
    let length = lengthof lhs;
    if (length != lengthof rhs) || (length == 0) {
        return -1;
    }
    let mut i = 0u;
    let mut cl: U8;
    let mut cr: U8;
    for i < length {
        cl = lhs[i];
        cr = rhs[i];
        if cl != cr {
            return cl - cr;
        }
        i += 1;
    }
    return 0;
}

pub fn find(str: [U8], substr: [U8]): UInt {
    if lengthof substr == 0 {
        return 0;
    }
    let mut i = 0u;
    for::outer i < lengthof str {
        if str[i] != substr[0] {
            i += 1;
            continue;
        }
        let mut j = 1u;
        for ((i + j) < lengthof str) && (j < lengthof substr) {
            if str[i + j] != substr[j] {
                i += 1;
                continue outer;
            }
            j += 1;
        }
        return i;
    }
    return UInt::MAX;
}

pub fn split(str: [U8], substr: [U8], consumer: fn([U8]): Int): Int {
    return split_ctx(str, substr, consumer as &mut U8, fn(ctx: &mut U8, split: [U8]): Int {
        return (ctx as fn([U8]): Int)(split);
    });
}

pub fn split_ctx(str: [U8], substr: [U8], ctx: &mut U8, consumer: fn(&mut U8, [U8]): Int): Int {
    let mut i = 0u;
    let mut view: [U8] = &str[i] ~ lengthof str - i;
    for i < lengthof str {
        let pos: UInt = find(view, substr);
        if pos == UInt::MAX {
            return consumer(ctx, view);
        }
        let result: UInt = consumer(ctx, &str[i] ~ pos);
        if result != 0 {
            return result;
        }
        i += pos + lengthof substr;
        view = &str[i] ~ lengthof str - i;
    }
    return 0;
}

pub fn is_digit(val: U8): Bool {
    return (val >= '0') && (val <= '9');
}

pub fn is_alpha(val: U8): Bool {
    return is_upper(val) || is_lower(val);
}

pub fn is_upper(val: U8): Bool {
    return (val >= 'A') && (val <= 'Z');
}

pub fn is_lower(val: U8): Bool {
    return (val >= 'a') && (val <= 'z');
}

pub fn to_lower(val: U8): U8 {
    if is_upper(val) {
        return toggle_case(val);
    }
    return val;
}

pub fn to_upper(val: U8): U8 {
    if is_lower(val) {
        return toggle_case(val);
    }
    return val;
}

pub fn toggle_case(val: U8): U8 {
    return val ^ 32;
}
