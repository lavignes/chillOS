pkg UInt;

use Ascii;
use U64;

pub let MAX: UInt = 0xFFFF_FFFF_FFFF_FFFFu;
pub let MIN: UInt = 0x0000_0000_0000_0000u;
pub let BITS: UInt  = sizeof UInt * 8;

pub fn is_err(val: !UInt): Bool {
    if let _ : UInt = val {
        return true;
    }
    return false;
}

pub fn min(lhs: UInt, rhs: UInt): UInt {
    if lhs < rhs {
        return lhs;
    }
    return rhs;
}

pub let ERR_OUT_OF_RANGE: Int = -1;
pub let ERR_MALFORMED: Int = -2;

pub fn parse(base: UInt, str: []U8): !UInt {
    let cutoff = MAX / base;
    let cutlim = MAX % base;
    let mut i = 0u;

    let mut val = 0u;
    for i < lengthof str {
        let mut c = str[i] as UInt;

        if Ascii::is_digit(c) {
            c -= '0';
        } else if Ascii::is_alpha(c) {
            if Ascii::is_upper(c) {
                c -= 'A' - 10;
            } else {
                c -= 'a' - 10;
            }
        } else {
            return ERR_MALFORMED err;
        }

        if c >= base {
            return ERR_MALFORMED err;
        }

        if (val > cutoff) || ((val == cutoff) && (c > cutlim)) {
            return ERR_OUT_OF_RANGE err;
        }

        val *= base;
        val += c;
        i += 1;
    }
    return val ok;
}
