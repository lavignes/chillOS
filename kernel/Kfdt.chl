// methods of reading Flattended Device Tree (FDT) or DeviceTree Blob (DTB)
// data fed in from the bootloader.
// see https://devicetree-specification.readthedocs.io
pkg Kfdt;

use U8;
use U32;
use UInt;
use Mem;
use Ascii;

pub type Iter = {
    parent: &U32, // address of parent node begin token (or 0)
    name: &U8,    // address of ASCIIZ name
    name_len: UInt,
    first_prop: &U32,  // address of first prop token (or 0)
    prop: &U32,        // address of current prop token (or 0)
    first_child: &U32, // address of first child begin node token (or 0)
    child: &U32,       // address of current child begin node token (or 0)
    addr_cells: UInt,  // width in U32s used to define bus address offsets of direct child nodes
    size_cells: UInt,  // width in U32s used to define bus address sizes of direct child nodes
};

pub type Tree = {
    structs_addr: &U32,
    strings_addr: &U8,
    readonly_mem_map_addr: &U8,
    root: Iter,
};

pub let ERR_BAD_MAGIC: Int = -1;
pub let ERR_BAD_VERSION: Int = -2;
pub let ERR_MALFORMED: Int = -3;

pub fn init_from_addr(tree: &mut Tree, addr: &U8): Int {
    let mut header: RawHeader;

    // all of the data in the fdt header is U32BE, we deserialize the header into LE
    U32::map(
        &mut header as &mut U8 as &mut U32, addr as &U32,
        sizeof RawHeader / sizeof U32,
        U32::endian_swap);

    if header.magic != 0xd00dfeed {
        return ERR_BAD_MAGIC;
    }
    if header.last_comp_version != 16 {
        return ERR_BAD_VERSION;
    }

    tree.structs_addr = (addr + (header.off_dt_struct as UInt)) as &U32;
    tree.strings_addr = (addr + (header.off_dt_strings as UInt)) as &U8;
    tree.readonly_mem_map_addr = addr + (header.off_mem_rsvmap as UInt);

    iter_init(tree, &mut tree.root, 0, tree.structs_addr);
    return 0;
}

pub type Uart = {
    model_name: &U8,
    model_name_len: UInt,
};

pub fn find_uart(tree: &mut Tree, uart: &mut Uart): Int {
    // for now, we'll assume a "chosen" uart is defined
    return 0;
}

fn rewind(iter: &mut Iter) {
    iter.prop = iter.first_prop;
    iter.child = iter.first_child;
}

let BEGIN_NODE: U32 = 0x0000_0001;
let END_NODE: U32 = 0x0000_0002;
let PROP: U32 = 0x0000_0003;
let NOP: U32 = 0x0000_0004;
let END: U32 = 0x0000_0009;

let PROP_ADDR_CELLS: [U8; 14] = "#address-cells";
let PROP_SIZE_CELLS: [U8; 11] = "#size-cells";

fn is_not_nop(val: U32): Bool {
    return U32::endian_swap(val) != NOP;
}

fn find_string(tree: &Tree, string_offset: U32, string: &mut &U8, string_len: &mut UInt): Int {
    *string = (tree.strings_addr + (string_offset as UInt)) as &U8;
    let string_null_byte_addr: &U8 = U8::find(*string, UInt::MAX, U8::is_zero);
    if string_null_byte_addr == 0 {
        return ERR_MALFORMED;
    }
    *string_len = string_null_byte_addr - *string;
    return 0;
}

// starting from a likely NOP/BEGIN_NODE token, walk forward and initialize an Iter
fn iter_init(tree: &Tree, iter: &mut Iter, parent: &U32, mut tok: &U32): Int {
    Mem::set(iter as &mut U8, sizeof Iter, 0);

    tok = U32::find(tok, UInt::MAX, is_not_nop);
    if (tok == 0) || (U32::endian_swap(*tok) != BEGIN_NODE) {
        return ERR_MALFORMED;
    }

    iter.parent = parent;
    // the node name is the next ptr after the BEGIN_NODE
    tok += 1;
    iter.name = tok as &U8;
    // following the name is possible padding bytes and the next token
    let name_null_byte_addr: &U8 = U8::find(iter.name, UInt::MAX, U8::is_zero);
    if name_null_byte_addr == 0 {
        return ERR_MALFORMED;
    }
    iter.name_len = name_null_byte_addr - iter.name;
    // add padding to align to next token
    tok = U32::align_to_next(name_null_byte_addr + 1);

    tok = U32::find(tok, UInt::MAX, is_not_nop);
    if tok == 0 {
        return ERR_MALFORMED;
    }
    // after this, we may have a PROP, the BEGIN_NODE of a child, or the END_NODE
    let mut val: U32 = U32::endian_swap(*tok);
    if val == PROP {
        iter.first_prop = tok;
        iter.prop = tok;
        // now we need to skip over the prop data and all subsequent props
        for val == PROP {
            tok += 1; // consume PROP token
            let prop_data_size: UInt = U32::endian_swap(*tok) as UInt;
            tok += 1; // consume data size
            let mut prop_name: &U8;
            let mut prop_name_len: UInt;
            if find_string(tree, U32::endian_swap(*tok), &mut prop_name, &mut prop_name_len) != 0 {
                return ERR_MALFORMED;
            }
            tok += 1; // consume name offset

            // if the property is one of #address-cells or #size-cells read them now
            if (prop_name_len == sizeof PROP_ADDR_CELLS)
                && Mem::equals(prop_name, &(PROP_ADDR_CELLS[0]), prop_name_len) {
                iter.addr_cells = U32::endian_swap(*tok);
            } else if (prop_name_len == sizeof PROP_SIZE_CELLS)
                && Mem::equals(prop_name, &(PROP_SIZE_CELLS[0]), prop_name_len) {
                iter.size_cells = U32::endian_swap(*tok);
            }
            // skip prop data, align to next token, and skip NOPs
            tok = U32::align_to_next((tok as &U8) + prop_data_size);
            tok = U32::find(tok, UInt::MAX, is_not_nop);
            if tok == 0 {
                return ERR_MALFORMED;
            }
            val = U32::endian_swap(*tok);
        }
    }
    // we now either have a BEGIN_NODE of a child, or the END_NODE
    if val == BEGIN_NODE {
        iter.first_child = tok;
        iter.child = tok;
    } else if val != END_NODE {
        return ERR_MALFORMED;
    }
    return 0;
}

type RawHeader = {
    magic: U32,
    totalsize: U32,
    off_dt_struct: U32,
    off_dt_strings: U32,
    off_mem_rsvmap: U32,
    version: U32,
    last_comp_version: U32,
    boot_cpuid_phys: U32,
    size_dt_strings: U32,
    size_dt_struct: U32,
};

