pkg U8;

use UInt;

pub let MIN: U8 = 0x00u8;
pub let MAX: U8 = 0xFFu8;
pub let BITS: UInt = sizeof U8 * 8;

pub let ERR_NOT_FOUND: Int = -1;

pub fn is_zero(val: U8): Bool {
    return val == 0;
}

pub fn find(items: [U8], predicate: fn(U8): Bool): !UInt {
    return find_ctx(items, predicate as &mut U8, fn(ctx: &mut U8, val: U8): Bool {
        return (ctx as fn(U8): Bool)(val);
    });
}

pub fn find_ctx(items: [U8], ctx: &mut U8, predicate: fn(&mut U8, U8): Bool): !UInt {
    let mut i = 0u;
    for i < lengthof items {
        if predicate(ctx, items[i]) {
            return i ok;
        }
        i += 1;
    }
    return ERR_NOT_FOUND err;
}

pub fn parse(base: UInt, str: [U8]): !U8 {
    if let uint: UInt = UInt::parse(base, str) {
        if uint > (MAX as UInt) {
            return UInt::ERR_OUT_OF_RANGE err;
        }
        return uint as U8 ok;
    } else e {
        return e err;
    }
}
